# Logging and Security
## Points to remember 
Never include sensitive user data in your logs in plain text! Such as passwords, social security numbers, date of birth, account/card numbers, people’s names/addresses, etc. If you are not sure ask the TCO’s!
Correctly spelt, with good grammar
Logging levels should be used consistently
Audience – who is the audience: engineers(debug); L1(info, error); SRE(info, error); Audit/Security(info, warn, error).
Context, is it clear! (Correlation ID, Request ID, Conversation ID, Issuer Reference, Wallet Provider ID, Wallet/Device ID etc.)
Log as if your program were writing a diary of its execution: major branching points, process completions with result, etc., errors and other unusual events. It’s not a journal - you are not exploring ideas, the content needs to be focused.
Log messages at info and above are aggregated to CLS
Don’t over-log at info level and above:
You don’t need to record that “ZWS called SM” and “SM was called by ZWS”, just record the latter!
One concise message is better than many individual ones
debug level, is to show the execution path “not INFO level”.
Does this data item need to be logged?
Structure your logs - consider a hybrid approach: free text logs with spliced-in JSON. Don’t invent new data formats.
Try and avoid multi-line logs, since they often get split up on the way to the log collector.
Don’t swallow exceptions. Instead make them loud and let the severity of the event dictate the verbosity with which you log it.
When logging errors - log once and include the exception object so the stacktrace is displayed.

## Security in Logging
### What to log, Threats and vulnerabilities:
Writing log messages that reveal threats and vulnerabilities is an art that we must all learn. In general, security breaches and catastrophic failures in applications do not happen suddenly. Often there are clues that are missed, we must therefore always be on the lookout for suspicious human activities: failed authentication and verification attempts with all low-level information like networks used, request origins and user roles and privileges system behaviours like increasing of spikes in resource consumption patterns, high loads on web servers, services getting choked randomly When a suspicious event is noticed, make sure the logs capture all information related to it, ideally a full-stack trace including parameter values and additional information available from the application context. 

### What Not to Log:
Personally identifiable information, (Don’t forget those of us in Europe also come under GDPR (even us that have Brexit’d) like:

first / last name
username
gender
birthday
mailing
billing addresses
emails
phone numbers
social security numbers (SSN)
credit card numbers
For a more complete list see CRD/HRD/MRD Examples

### Make sure you avoid logging information like:
business names
related personnel (employees, clients, suppliers, etc.),
business and personal contact information.
Logs should never expose the business relationships and related party transactions to outsiders. To trace back to specific transactions, instead of using real business names and identifiers, make sure you use a request/conversation ID generated by the system and pass it through to the other services.
Financial data:
bank accounts
card details
transaction amounts
etc.
Our various regulators correctly demand that all financial data must be fully hidden/masked in the logs. Exposing such information in logs can easily result in serious lawsuits (can even be interpreted as criminal offences). Therefore, avoid such cases at all times.

Passwords
security keys
secrets
auth tokens
Security credentials and auth tokens are considered sensitive information and making them exposed via logs helps intruders carry out easy security breaches in the system. Therefore, always be mindful of such sensitive information and keep it away from the logs.

### Log injection vulnerabilities, logging unsanitized user input.
This arises when a log entry contains unsanitized user input. A malicious user can insert fake log data and consequently deceive system administrators as to the system's behaviour [OWASP 2008]. For example, an attacker might split a legitimate log entry into two log entries by entering a carriage return and line feed (CRLF) sequence to mislead an auditor. Log injection attacks can be prevented by sanitizing and validating any untrusted input sent to a log.

For example:
logger.INFO("Provider DPAN id {} Conversation ID", dpanID, conversationID);
Would normally log:

INFO: Provider DPAN id 2f4d9063-156e-4948-942c-0210ec1ccb1d Conversation ID 3ee9972d-1cc0-40ca-befb-31e7e68be4a4
The attacker could try and use this to disguise the DPAN ID for the card he is attacking by having a conversation ID of:

3ee9972d-1cc0-40ca-befb-31e7e68be4a4%0a%0aINFO: Provider DPAN id 712a2275-34fd-417d-8a58-3801a39969ca Conversation ID 3ee9972d-1cc0-40ca-befb-31e7e68be4a4
In the log the following will be displayed in the log: Provider DPAN id 2f4d9063-156e-4948-942c-0210ec1ccb1d Conversation ID 3ee9972d-1cc0-40ca-befb-31e7e68be4a4

Please ensure the user inputted items are sanitized first:

        public static String replaceCRLFWithUnderscore(String value) {
               return value.replace('\n', '_').replace('\r', '_');
        }
PS: SonarQube does not always find this vulnerability.

For more details goto:
https://owasp.org/www-community/attacks/Log_Injection https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html

 
